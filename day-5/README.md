# День 5.

## :house: Домашнее задание

### Задачи

1. Изменить ваш фал [`validation.php`](../day-4/validation.php) из четвертого ДЗ. Вся валидация должно быть инкапсулирвана в одном классе Validation.
1. В файле [`hw4.php`](../day-4/hw4.php) из четвертого ДЗ изменить исползование валидации на ООП реализациюю. См. [`hw5.php`](./hw5.php). 

### На проверку
- Файл `validation.php`
- Файл `hw5.php`

## :tv: [Запись онлайн-занятия](https://zoom.us/rec/share/_fZSCZ7M5kpJbIWV4hzFd5IqAIC4eaa8hikd8_QOy-yavzpdMcgFjyi56Anjnn8?startTime=1585060893000)

## :scroll: Конспект

### ООП

ООП в PHP 7 в целом схоже с ООП в других языках программирования.

Базовый синтаксис классов

```PHP
class A {

  # Свойства класса (могут иметь знчения по умолчанию)

  private $private = "is";
  protected $protected = "Something";
  public $public;
  
  # Методы класса объявляются как функции с указанием области видимости

  private function private($arg) { 
  }

  protected function protected($arg) { 
  }

  public function public($arg) { 
  }

  # Конструктор это метод с именем __construct

  public function __construct($arg) {
    // Обращение к свойствам и методам объекта изнутри 
    // осуществляется с помощью псевдопеременной $this и оператора ->
    $this->private = $arg;
    $this->private($arg);
    // ! Заметьте знак $ не ставится перед именем свойства в этом случае!
  }

  # Константы. Ключевое слово const, имя без $
  const CONST = 10;

  # Статические свойства и методы

  static public $static_public;


  static public function static_public() {
    // Оператор :: позволяет обрщаться к статическим совйствам и методам
    // Можно применять к имени класса
    A::$static_public = 1;

    // Можно применять к слову self
    // self ВСЕГДА ссылается на класс в котором объявлен этот метод 
    self::$static_public = 2;

    // Можно применять к слову static
    // static ВСЕГДА ссылается на класс в котором этот метод был вызван (например потомок)
    static::$static_public = 3;
  }

}

// Создание экземпляра объекта
$a = new A("a");

// Обращение к совйствам и методам
$a->public = 4;
$a->public(5);

// Обращение к статическим совйствам, константам  и методам
A::$static_public = A::CONST;
A::static_public();
```

Наследование и интерфесы 

```PHP
abstract class A {
  public abstract function abstract();
}

interface I1 {
  public function i_1_method();
}

interface I2 {
  public function i_2_method();
}

class B extends A implements I1, I2 {
  public function abstract() {
    
  }

  public function i_1_method() {

  }

  public function i_2_method() {

  }
}
```

Трейты. Являются не классами (т.е. нельзя создавать экземпляры трейтов), но коллекцией методов. Служат в некотором смысле альтернативой множественному наследованию. 

```PHP

trait T1 {
  public function t_1_method() {
    // do stuff
  }
}

trait T2 {
  public function t_2_method() {
    // do stuff
  }
}

class B {
  use T1, T2;

}

$b = new B();
$b->t_1_method();
$b->t_2_method();
```

Некоторые особенности PHP

1.  Нет базового класса типа `Object` от которого наследуют все остальные классы (как во многих других ООП языках). Чтобы проверить что значение переменной объект нужно использовать функцию `is_object`

1.  Т.к. нет класса `Object`, то нет стандартного набора методов присутсвующих во всех классах типа `toString` или `equals`.  
    Для реализиции конвертирования объекта в строку есть "магический" метод: 
    ```PHP
    class A {
      function __toString() {
        return "Stringified";
      }
    }

    var_dump(new A()); // выведет "Stringified"
    ```
    
    Реализовать специальное сравнения для класса универсальным способом нельзя. Но важно, что операторы сравнения `==` и `===` применимы к объектам.  
    `===` считает равными два объекта, которые являются одним экземпляром одного класса: 
    ```PHP
    class A {
      public $val;
    }

    $a = new A();
    $b = $a;
    $c = new A();
    var_dump($a === $b); // true
    var_dump($a === $c); // false
    ```

    `==` считает равными два объекта, елси они являются экземплярами одного класса и они имеют одинаковый набор свойств и все их свойства равны.

    ```PHP
    
    $a = new A();
    $a->val = 1;
    $b = new A();
    $b->val = 2;
    var_dump($a == $b); // false
    $b->val = 1;
    var_dump($a == $b); // true
    $b->otherVal = 1;
    var_dump($a == $b); // false
    ```

1.  Создание совйств объекта "на лету" не является ошибкой. Но попытка получить зачение еще не существующего свойства - ошибка.
    ```PHP
    class A {}
    $a = new A();

    $a->undefined = 10; // ОК
    $tmp = $a->anotherUndefined; // Ошибка: свойство не существует
    ```

1.  Существует класс `stdClass`, который не содержит никаких свойств и методов. Но учитывая вышесказанное, может быть использован как динамичское хранилище
    ```PHP
    $a = new stdClass();
    $a->val1 = 123;
    $a->val1 = "123";
    var_dump($a);
    ```

1.  Такое динамеческое добавление свойств в объекты - не очень хороший подход. Если вам действительно необходимо реализовать такой функционал, то лучше использовать "магические" методы `__set`, `__get`, `__isset`, `__unset`, котоыре позволяют управлять логикой работы с неопределенными свойствами объекта. Аналогично есть методы `__call`, `__callStatic` реагирующие на вызов неопределенного метода.  
В целом в "магические" методы, это такие методы, кторые "магическим" образом вызываются ПХП в опредленых сценариях. Подробнее можно прочитать здесь https://www.php.net/manual/ru/language.oop5.magic.php